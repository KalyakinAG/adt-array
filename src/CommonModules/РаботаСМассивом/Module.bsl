//  Подсистема "Абстрактный тип данных массив"
//	Автор: Калякин Андрей Г.
//  https://github.com/KalyakinAG/adt-array
//  https://infostart.ru/1c/articles/1473034/

//@skip-check module-unused-local-variable
//@skip-check method-optional-parameter-before-required

#Область ПрограммныйИнтерфейс

#Область АбстрактныеФункции

// find - поиск элемента коллекции
// 
// Параметры:
//  Элементы - Массив из Произвольный - любая коллекция, которая поддерживает Для Каждого 
//  ВыражениеПредиката - Строка - выражение, при вычислении которого для искомого элемента возвращается Истина
//  Контекст - Произвольный - Контекст, который может быть использован для вызова функции
//  Параметры - Произвольный - Параметры, которые могут быть использованы при вычислении функции
// 
// Возвращаемое значение:
//  Неопределено, Произвольный - найденный элемент
Функция НайтиЭлемент(Элементы, ВыражениеПредиката, Контекст = Неопределено, Параметры = Неопределено) Экспорт
	#Если НЕ ТонкийКлиент Тогда
		УстановитьБезопасныйРежим(Истина);
	#КонецЕсли
	Выражение = Нормализовать(ВыражениеПредиката);
	Для Каждого Элемент Из Элементы Цикл
		Если Вычислить(Выражение) Тогда
			Возврат Элемент;
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;
КонецФункции

// index
// 
// Параметры:
//  Элементы - Массив из Произвольный - любая коллекция, которая поддерживает Для Каждого 
//  ВыражениеПредиката - Строка - выражение, при вычислении которого для искомого элемента возвращается Истина
//  Контекст - Произвольный - Контекст, который может быть использован для вызова функции
//  Параметры - Произвольный - Параметры, которые могут быть использованы при вычислении функции
// 
// Возвращаемое значение:
//  Неопределено, Число - Индекс
Функция Индекс(Элементы, ВыражениеПредиката, Контекст = Неопределено, Параметры = Неопределено) Экспорт
	#Если НЕ ТонкийКлиент Тогда
		УстановитьБезопасныйРежим(Истина);
	#КонецЕсли
	Выражение = Нормализовать(ВыражениеПредиката);
	Для Индекс = 0 По Элементы.Количество() - 1 Цикл
		Элемент = Элементы[Индекс];
		Если Вычислить(Выражение) Тогда
			Возврат Индекс;
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;
КонецФункции

// filter
// 
// Параметры:
// Параметры:
//  Элементы - Массив из Произвольный - любая коллекция, которая поддерживает Для Каждого 
//  ВыражениеПредиката - Строка - выражение, при вычислении которого для искомого элемента возвращается Истина
//  Контекст - Произвольный
//  Параметры - Произвольный
// 
// Возвращаемое значение:
//  Массив из Произвольный - новый массив отобранных элементов
Функция Отобрать(Элементы, ВыражениеПредиката, Контекст = Неопределено, Параметры = Неопределено) Экспорт
	#Если НЕ ТонкийКлиент Тогда
		УстановитьБезопасныйРежим(Истина);
	#КонецЕсли
	Выражение = Нормализовать(ВыражениеПредиката);
	НайденныеЭлементы = Новый Массив;
	Для Каждого Элемент Из Элементы Цикл
		Если Вычислить(Выражение) Тогда
			НайденныеЭлементы.Добавить(Элемент);
		КонецЕсли;
	КонецЦикла;
	Возврат НайденныеЭлементы;
КонецФункции

// map
// 
// Параметры:
//  Элементы - Массив из Произвольный - любая коллекция, которая поддерживает Для Каждого 
//  ВыражениеОтображения - Строка - выражение, при вычислении которого для искомого элемента возвращается Истина
//  Контекст - Произвольный
//  Параметры - Произвольный
// 
// Возвращаемое значение:
//  Массив из Произвольный - новый массив отображенных элементов
Функция Отобразить(Элементы, ВыражениеОтображения, Контекст = Неопределено, Параметры = Неопределено) Экспорт
	#Если НЕ ТонкийКлиент Тогда
		УстановитьБезопасныйРежим(Истина);
	#КонецЕсли
	Выражение = Нормализовать(ВыражениеОтображения);
	НовыеЭлементы = Новый Массив;
	Если ТипЗнч(Элементы) = Тип("Массив") Тогда
		Для Индекс = 0 По Элементы.ВГраница() Цикл
			Элемент = Элементы[Индекс];
			НовыеЭлементы.Добавить(Вычислить(Выражение));
		КонецЦикла;
	Иначе
		Для Каждого Элемент Из Элементы Цикл
			НовыеЭлементы.Добавить(Вычислить(Выражение));
		КонецЦикла;
	КонецЕсли;
	Возврат НовыеЭлементы;
КонецФункции

// reduce
// МаксимальныйУровень = РаботаСМассивом.АТДМассив(ПоказателиРасчета)
// .Отобразить("Макс(Накопитель, Элемент.Уровень)", 0)
// ;
// //  Группировка показателей по уровням
// Показатели = РаботаСМассивом.АТДМассив(ПоказателиРасчета)
// .Отобразить("Элемент.Значение")
// .Преобразовать("
// |ОбщийКлиентСервер.ВставитьСвойство(
// |	Накопитель,
// |	Элемент.Уровень,
// |	?(Накопитель[Элемент.Уровень] = Неопределено,
// |		ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Элемент),
// |		РаботаСМассивом.Дополнить(Накопитель[Элемент.Уровень], ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Элемент))
// |	)
// |)", Новый Соответствие)
// ;
// //  Пересборка соответствия
// ЭлементыПоказателей = РаботаСМассивом.АТДМассив(Показатели)
// .Преобразовать("ОбщийКлиентСервер.ВставитьСвойство(Накопитель, Элемент.Ключ, РаботаСМассивом.Отобразить(Элемент.Значение, ' ''ЗначенияПоказателей'' + Элемент.Код'))", Новый Соответствие)
// ;
// 
// Параметры:
//  Элементы - Массив из Произвольный - любая коллекция, которая поддерживает Для Каждого
//  ВыражениеПреобразования - Строка - выражение функции от Ф(Накопитель)
//  НачальноеЗначение - Неопределено - Начальное значение
//  Контекст - Произвольный - 
//  Параметры - Произвольный - 
// 
// Возвращаемое значение:
//  Произвольный - итоговый результат преобразования
Функция Преобразовать(Элементы, ВыражениеПреобразования, НачальноеЗначение = Неопределено, Контекст = Неопределено, Параметры = Неопределено) Экспорт
	#Если НЕ ТонкийКлиент Тогда
		УстановитьБезопасныйРежим(Истина);
	#КонецЕсли
	Выражение = Нормализовать(ВыражениеПреобразования);
	Накопитель = НачальноеЗначение;
	Для Каждого Элемент Из Элементы Цикл
		Накопитель = Вычислить(Выражение);
	КонецЦикла;
	Возврат Накопитель;
КонецФункции

// forEach
// Оформлена как функция для того, чтобы использовать 
// 
// Параметры:
//  Элементы - Массив из Произвольный - любая коллекция, которая поддерживает Для Каждого 
//  АлгоритмОбработки - Строка - 
//  Контекст - Произвольный
//  Параметры - Произвольный
// 
Процедура ДляКаждого(Элементы, АлгоритмОбработки, Контекст = Неопределено, Параметры = Неопределено) Экспорт
	#Если НЕ ТонкийКлиент Тогда
		УстановитьБезопасныйРежим(Истина);
	#КонецЕсли
	Алгоритм = Нормализовать(АлгоритмОбработки);
	Если СтрРазделить(Алгоритм, ";" + Символы.ПС).ВГраница() > 0 Тогда
		ВызватьИсключение "Нельзя использовать многострочные алгоритмы для обработки элементов массива!";
	КонецЕсли;
	Для Каждого Элемент Из Элементы Цикл
		#Если НЕ ВебКлиент Тогда
			Выполнить(Алгоритм);
		#КонецЕсли
	КонецЦикла;
КонецПроцедуры

#КонецОбласти

#Область Операции

Функция Первый(Элементы) Экспорт
	ВГраница = Элементы.ВГраница();
	Если ВГраница = -1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = Элементы[0];
	Возврат Результат;
КонецФункции

// last
// 
// Параметры:
//  Элементы - Массив из Произвольный
// 
// Возвращаемое значение:
//  Произвольный
Функция Последний(Элементы) Экспорт
	ВГраница = Элементы.ВГраница();
	Если ВГраница = -1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = Элементы[ВГраница];
	Возврат Результат;
КонецФункции

// pop
// Взять последний элемент с удалением из массива
// 
// Параметры:
//  Элементы - Массив из Произвольный
// 
// Возвращаемое значение:
//  Произвольный
Функция Взять(Элементы) Экспорт
	ВГраница = Элементы.ВГраница();
	Если ВГраница = -1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = Элементы[ВГраница];
	Элементы.Удалить(ВГраница);
	Возврат Результат;
КонецФункции

// shift
// Взять первый элемент с удалением из массива
// 
// Параметры:
//  Элементы - Массив из Произвольный
// 
// Возвращаемое значение:
//  Произвольный
Функция Сдвинуть(Элементы) Экспорт
	ВГраница = Элементы.ВГраница();
	Если ВГраница = -1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = Элементы[0];
	Элементы.Удалить(0);
	Возврат Результат;
КонецФункции

// add
// Добавить элемент
// 
// Параметры:
//  Элементы - Массив из Произвольный - 
//  Элемент - Произвольный
// 
// Возвращаемое значение:
//  Массив из Произвольный
Функция Добавить(Элементы, Элемент) Экспорт
	Элементы.Добавить(Элемент);
	Возврат Элементы;
КонецФункции

#КонецОбласти

#Область СрезыДиапазоныИтераторы

// slice
// 
// Параметры:
//  Элементы - Массив из Произвольный - 
//  НижняяГраница - Число - Нижняя граница
//  ВерхняяГраница - Число - Верхняя граница
//  Шаг - Число - Шаг
// 
// Возвращаемое значение:
//  Массив из Произвольный
Функция Срез(Элементы, Знач НижняяГраница = 0, Знач ВерхняяГраница = Неопределено, Шаг = 1) Экспорт
	Результат = Новый Массив;
	Если НижняяГраница < 0 Тогда
		НижняяГраница = Элементы.Количество() + НижняяГраница;
		Если НижняяГраница < 0 Тогда
			НижняяГраница = 0;
		КонецЕсли;
	КонецЕсли;
	Если ВерхняяГраница = Неопределено ИЛИ ВерхняяГраница > Элементы.Количество() Тогда
		ВерхняяГраница = Элементы.Количество();
	КонецЕсли;
	Индекс = НижняяГраница;
	Пока Индекс < ВерхняяГраница Цикл
		Результат.Добавить(Элементы[Индекс]);
		Индекс = Индекс + Шаг;
	КонецЦикла;
	Возврат Результат;
КонецФункции

// range
// 
// Параметры:
//  НижняяГраница - Число
//  ВерхняяГраница - Число
//  Шаг - Число - Шаг
// 
// Возвращаемое значение:
//  Массив из Произвольный
Функция Диапазон(НижняяГраница, ВерхняяГраница, Шаг = 1) Экспорт
	Если НижняяГраница >= ВерхняяГраница Тогда
		Возврат Новый Массив;
	КонецЕсли;
	Результат = Новый Массив;
	Индекс = НижняяГраница;
	Пока Истина Цикл
		СледующийИндекс = Индекс + Шаг;
		Если СледующийИндекс > ВерхняяГраница Тогда
			Прервать;
		КонецЕсли;
		Результат.Добавить(Индекс);
		Индекс = СледующийИндекс;
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Следующий
// обход по данным
// 
// Параметры:
//  Индекс - Число - исходящий параметр текущего индекса
//  Элемент - Произвольный - исходящий параметр текущего элемента
//  Элементы - Массив из Произвольный
//  Шаг - Число - Шаг, позволяет выполнять обход по данным заданной ширины
// 
// Возвращаемое значение:
//  Булево - Следующий
Функция Следующий(Индекс, Элемент, Элементы, Шаг = 1) Экспорт
	Если Индекс = Неопределено Тогда
		Индекс = 0;
	Иначе
		Индекс = Индекс + Шаг;
	КонецЕсли;
	Если Индекс > Элементы.ВГраница() Тогда
		Возврат Ложь;
	КонецЕсли;
	Элемент = Элементы[Индекс];
	Возврат Истина;
КонецФункции

#КонецОбласти

#Область Преобразования

// flat
// 
// Параметры:
//  Элементы - Массив из Произвольный - любая коллекция, которая поддерживает Для Каждого
//  Глубина - Число - глубина вложенности массивов
// 
// Возвращаемое значение:
//  Массив из Произвольный - новый массив элементов на одном уровне
Функция Спрямить(Элементы, Глубина = Неопределено) Экспорт
	СледующаяГлубина = ?(Глубина = Неопределено, Неопределено, Глубина - 1);
	НовыеЭлементы = Новый Массив;
	Для Каждого Элемент Из Элементы Цикл
		Если ТипЗнч(Элемент) = Тип("Массив") И (СледующаяГлубина = Неопределено ИЛИ СледующаяГлубина >= 0) Тогда
			Дополнить(НовыеЭлементы, Спрямить(Элемент, СледующаяГлубина));
			Продолжить;
		КонецЕсли;
		НовыеЭлементы.Добавить(Элемент);
	КонецЦикла;
	Возврат НовыеЭлементы;
КонецФункции

// group
// 
// Параметры:
//  Элементы - Массив из Структура - любая коллекция, которая поддерживает Для Каждого
//  ПоляГруппировки - Строка, Неопределено - Поля группировки
//  ПоляСвертки - Строка, Неопределено - Поля, значения из которых преобразуются в массив
// 
// Возвращаемое значение:
//  Массив из Структура - массив, где свойства структуры - значения группировочных полей, 
//                       а свойства итога - массивы сгруппированных значений
Функция Свернуть(Элементы, ПоляГруппировки = Неопределено, ПоляСвертки = Неопределено) Экспорт
	
	Результат = Новый Массив;
	СписокПолейСвертки = Массив(ПоляСвертки);
		
	Если ЗначениеЗаполнено(ПоляГруппировки) Тогда
		
		Группировки = РаботаСМножеством.Множество(ПоляГруппировки);
		
		Для Каждого Элемент Из Элементы Цикл
			
			Группировка = НовыйГруппировка(ПоляГруппировки, СписокПолейСвертки);
			ЗаполнитьЗначенияСвойств(Группировка, Элемент, ПоляГруппировки);
	
			Если РаботаСМножеством.Добавить(Группировки, Группировка) Тогда
				Результат.Добавить(Группировка);
			КонецЕсли;
			
			Для Каждого ИмяПоляСвертки Из СписокПолейСвертки Цикл
				Группировка[ИмяПоляСвертки].Добавить(Элемент[ИмяПоляСвертки]);
			КонецЦикла;
		
		КонецЦикла;
		
		Возврат Результат;
	
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПоляСвертки) Тогда
		
		Группировка = НовыйГруппировка(, ПоляСвертки);
		
		Для Каждого Элемент Из Элементы Цикл
			
			Для Каждого ИмяПоляИтога Из СписокПолейСвертки Цикл
				Группировка[ИмяПоляИтога].Добавить(Элемент[ИмяПоляИтога]);
			КонецЦикла;
			
		КонецЦикла;
		
		Результат.Добавить(Группировка);
		Возврат Результат;
		
	КонецЕсли;

	Результат = Дополнить(Новый Массив, Элементы, Истина);
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область АгрегатныеФункции

Функция Сумма(Элементы) Экспорт
	Результат = 0;
	Для Каждого Элемент Из Элементы Цикл
		Результат = Результат + Элемент;	
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция Максимум(Элементы) Экспорт
	Результат = 0;
	Для Каждого Элемент Из Элементы Цикл
		Если Элемент > Результат Тогда
			Результат = Элемент;
		КонецЕсли;	
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция Минимум(Элементы) Экспорт
	Результат = 0;
	Для Каждого Элемент Из Элементы Цикл
		Если Элемент < Результат Тогда
			Результат = Элемент;
		КонецЕсли;	
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция Среднее(Элементы) Экспорт
	Возврат Сумма(Элементы) / Элементы.Количество();
КонецФункции

Функция Количество(Элементы) Экспорт
	Возврат Элементы.Количество();
КонецФункции

Функция КоличествоРазличных(Элементы, ПоляГруппировки = Неопределено) Экспорт
	Возврат Свернуть(Элементы, ПоляГруппировки).Количество();
КонецФункции

#КонецОбласти

#Область Контруктор

// АТДМассив.
// 
// Параметры:
//  Элементы - Массив из Произвольный - любая коллекция, которая поддерживает Для Каждого 
// 
// Возвращаемое значение:
//  ОбработкаОбъект.АТДМассив, ФормаКлиентскогоПриложения - АТДМассив
Функция АТДМассив(Элементы = Неопределено) Экспорт
	#Если Клиент Тогда
        АТДМассив = ПолучитьФорму("Обработка.АТДМассив.Форма.Форма");
    #Иначе
        АТДМассив = Обработки.АТДМассив.Создать();
    #КонецЕсли
	Если Элементы <> Неопределено Тогда
		АТДМассив.Установить(Элементы);
	КонецЕсли;
	Возврат АТДМассив;
КонецФункции

// Возвращает массив в свойств. Требования к свойствам такие же как при объявлении структуры.
// 
// Параметры:
//	Значение	- Строка - свойства через запятую, которые преобразуются в массив 
//              - Массив из Произвольный - возвращается в исходном значении
// Возвращаемое значение:
//	- Массив из Строка - свойства в массиве
//	- Массив из Произвольный - исходный массив
//
Функция Массив(Значение) Экспорт
	Если НЕ ЗначениеЗаполнено(Значение) Тогда
		Возврат Новый Массив;
	КонецЕсли;
	ТипЗначения = ТипЗнч(Значение);
	Если ТипЗначения = Тип("Массив") Тогда
		Возврат Значение;
	КонецЕсли;
	Если ТипЗначения = Тип("Строка") Тогда
		Возврат СтрРазделить(СтрЗаменить(СтрЗаменить(Значение, " ", ""), Символы.ПС, ""), ",", Ложь);
	КонецЕсли;
	Если ТипЗначения = Тип("Структура") 
		ИЛИ ТипЗначения = Тип("ФиксированнаяСтруктура")
		ИЛИ ТипЗначения = Тип("Соответствие")
		ИЛИ ТипЗначения = Тип("ФиксированноеСоответствие") Тогда
			Результат = Новый Массив;
			Для Каждого КлючЗначение Из Значение Цикл
				Результат.Добавить(Новый Структура("Ключ, Значение", КлючЗначение.Ключ, КлючЗначение.Значение));
			КонецЦикла;	
			Возврат Результат;
	КонецЕсли;
	Возврат Новый Массив;
КонецФункции

Функция ВСтруктуру(Элементы, ПолеКлюча = "Ключ", ПолеЗначения = "Значение") Экспорт
	Результат = Новый Структура;
	Для Каждого Элемент Из Элементы Цикл
		Результат.Вставить(Элемент[ПолеКлюча], Элемент[ПолеЗначения]);
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ВСоответствие(Элементы, ПолеКлюча = "Ключ", ПолеЗначения = "Значение") Экспорт
	Результат = Новый Соответствие;
	Для Каждого Элемент Из Элементы Цикл
		Результат.Вставить(Элемент[ПолеКлюча], Элемент[ПолеЗначения]);
	КонецЦикла;
	Возврат Результат;
КонецФункции
	
#КонецОбласти

#Область Отображения

Функция ОтобразитьСвойства(Элементы, СоответствиеСвойств, ПутьОтображения = Неопределено) Экспорт
	Результат = Новый Массив;
	Для Каждого Элемент Из Элементы Цикл
		НовыйЭлемент = ОбщийКлиентСервер.ОтобразитьСвойства(Элемент, СоответствиеСвойств);
		Если ЗначениеЗаполнено(ПутьОтображения) Тогда
			ЭлементыОтображения = Массив(ОбщийКлиентСервер.СвойствоРекурсивно(Элемент, ПутьОтображения));
			Для Каждого ЭлементОтображения Из ЭлементыОтображения Цикл
				ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(ЭлементОтображения, НовыйЭлемент, Истина);
			КонецЦикла;
			Результат.Добавить(ЭлементыОтображения);
			Продолжить;
		КонецЕсли;
		Результат.Добавить(НовыйЭлемент);
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ВставитьСвойство(Элементы, Свойство, ВыражениеОтображения, Контекст = Неопределено, Параметры = Неопределено) Экспорт
	#Если НЕ ТонкийКлиент Тогда
		УстановитьБезопасныйРежим(Истина);
	#КонецЕсли
	Выражение = Нормализовать(ВыражениеОтображения);
	Результат = Новый Массив;
	Для Каждого Элемент Из Элементы Цикл
		Значение = Вычислить(Выражение);
		Если ТипЗнч(Элемент) = Тип("Структура") Тогда
			НовыйЭлемент = ОбщийКлиентСервер.СкопироватьСтруктуру(Элемент);
		Иначе
			НовыйЭлемент = Новый Структура;
		КонецЕсли;
		НовыйЭлемент = ОбщийКлиентСервер.ВставитьСвойство(НовыйЭлемент, Свойство, Значение);
		Результат.Добавить(НовыйЭлемент);
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ВставитьСвойствоРекурсивно(Элементы, Путь, ВыражениеОтображения) Экспорт
	#Если НЕ ТонкийКлиент Тогда
		УстановитьБезопасныйРежим(Истина);
	#КонецЕсли
	Выражение = Нормализовать(ВыражениеОтображения);
	Результат = Новый Массив;
	Для Каждого Элемент Из Элементы Цикл
		Значение = Вычислить(Выражение);
		НовыйЭлемент = ОбщийКлиентСервер.ВставитьСвойствоРекурсивно(Элемент, Путь, Значение);
		Результат.Добавить(НовыйЭлемент);
	КонецЦикла;
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область СортировкаИРаспределение

// Поля сравнения
// 
//  Параметры:
//    Поля	- Строка - поля через запятую с указанием направления сортировки +/-
//    		- Массив из Строка
//  Возвращаемое значение:
//    Массив из Структура:
//		* Поле - Строка
//		* Направление - Строка - "+"/"-"
Функция ПоляСравнения(Поля) Экспорт
	ПоляСравнения = Новый Массив;
	Для Каждого Поле Из Массив(Поля) Цикл
		Направление = Прав(Поле, 1);
		Если Направление = "+" ИЛИ Направление = "-" Тогда
			ПоляСравнения.Добавить(Новый Структура("Поле, Направление", Лев(Поле, СтрДлина(Поле) - 1), Направление));
		Иначе
			ПоляСравнения.Добавить(Новый Структура("Поле, Направление", Поле, "+"));
		КонецЕсли;
	КонецЦикла;
	Возврат ПоляСравнения;
КонецФункции

// Сравнить значение А с Б. Нормальный порядок в сторону увеличения от А к Б, т.е. условно
// Б - А > 0, иначе < 0 - это будет уменьшение.
// 
// Параметры:
//  А - Произвольный - сравниваемое значение 1  
//  Б - Произвольный - сравниваемое значение 2
//  Направление - Строка - символы: "+" - увеличение (по-умолчанию), "-" - уменьшение
// 
// Возвращаемое значение:
//  Число - < 0, сортировка поставит 1-ое значение по меньшему индексу, чем 2-ое, 
//			= 0, сортировка не меняет индексы значений,
//			> 0, сортировка поставит 2-ое значение по меньшему индексу, чем 1-ое 
Функция Сравнить(А, Б, Направление = "+") Экспорт
	Если А = Б Тогда
		Возврат 0;
	КонецЕсли;
	Результат = ?(А < Б, -1, 1);
	Возврат ?(Направление = "-", -Результат, Результат); 
КонецФункции

// Сравнивает два структурных объекта. Сравнивается каждое поле отдельно и если они не равны, то сразу определяется порядок.
// Т.е. принцип такой: находится первое неравенство и оно как больший разряд определяет порядок элементов.
// 
// Параметры:
//  А - Произвольный
//  Б - Произвольный
//  ПоляСравнения - см. ПоляСравнения
// 
// Возвращаемое значение:
//  Число - см. Сравнить
Функция СравнитьПо(А, Б, ПоляСравнения) Экспорт
	Для Каждого ПолеСравнения Из ПоляСравнения Цикл
		Поле = ПолеСравнения.Поле;
 		Результат = Сравнить(А[Поле], Б[Поле], ПолеСравнения.Направление);
		Если Результат <> 0 Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	Возврат 0;
КонецФункции

// sortBy
// Процедура меняет исходный массив и возвращает его же. Возврат может быть использован в
// рекурсивном вызове типа СортироватьПо(Отобразить(Элементы, 'Элемент.Значение'), "Имя")
// 
// Параметры:
//  Элементы - Массив из Произвольный - 
//  Поля - Строка - поля через запятую с указанием направления сортировки +/-
// 
// Возвращаемое значение:
//  Массив из Произвольный - Сортировать по
Функция СортироватьПо(Элементы, Знач Поля) Экспорт
	ПоляСравнения = ПоляСравнения(Поля);
	БыстраяСортировкаПо(Элементы, ПоляСравнения, 0, Элементы.ВГраница());
	Возврат Элементы;
КонецФункции

// sort
// Процедура меняет исходный массив и возвращает его же. Возврат может быть использован в
// рекурсивном вызове типа Сортировать(Отобразить(Элементы, 'Элемент.Ключ'))
// 
// Параметры:
//  Элементы - Массив из Произвольный - 
//  ФункцияСравнения - Строка - для сортировки простых типов: "+" - сортировка по возрастанию (по-умолчанию), "-" - по убыванию
// Требования к функции
// См. Сравнить
//  Контекст - Произвольный - может быть использовать в функции сравнения
//  Параметры - Произвольный - могут быть использованы в функции сравнения
// 
// Возвращаемое значение:
//  Массив из Произвольный - Сортировать
Функция Сортировать(Элементы, Знач ФункцияСравнения = Неопределено, Контекст = Неопределено, Параметры = Неопределено) Экспорт
	Если НЕ ЗначениеЗаполнено(ФункцияСравнения) ИЛИ ФункцияСравнения = "+" Тогда
		Список = Новый СписокЗначений;
		Список.ЗагрузитьЗначения(Элементы);
		Список.СортироватьПоЗначению();
		Элементы = Список.ВыгрузитьЗначения();
		Возврат Элементы;
	ИначеЕсли ФункцияСравнения = "-" Тогда
		Список = Новый СписокЗначений;
		Список.ЗагрузитьЗначения(Элементы);
		Список.СортироватьПоЗначению(НаправлениеСортировки.Убыв);
		Элементы = Список.ВыгрузитьЗначения();
		Возврат Элементы;
	КонецЕсли;
	ФункцияСравнения = Нормализовать(ФункцияСравнения);
	БыстраяСортировка(Элементы, ФункцияСравнения, Контекст, Параметры, 0, Элементы.ВГраница());
	Возврат Элементы;
КонецФункции

// Сортировать элементы дерева данных формы
// 
// Параметры:
//  Элементы - ДанныеФормыКоллекцияЭлементовДерева - 
//  ФункцияСравнения - Строка - см. Сравнить
//  СортироватьВложенные - Булево
Процедура СортироватьЭлементыКоллекции(Элементы, ФункцияСравнения = Неопределено, СортироватьВложенные = Истина) Экспорт
	Если ЗначениеЗаполнено(ФункцияСравнения) Тогда
		Выражение = Нормализовать(ФункцияСравнения);
	Иначе
		Выражение = "Сравнить(А.Наименование, Б.Наименование)";
	КонецЕсли;
	Если Элементы.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	Если СортироватьВложенные Тогда
		Для Каждого ЭлементДерева Из Элементы Цикл
			СортироватьЭлементыКоллекции(ЭлементДерева.ПолучитьЭлементы(), Выражение, СортироватьВложенные);
		КонецЦикла;
	КонецЕсли;
	СортироватьЭлементы(Элементы, Выражение, 0, Элементы.Количество() - 1);
КонецПроцедуры

// Порядок определяется алгоритмом рекурсивного спуска по вершинам графа. Чем выше порядок, тем выше вершина
// 4 - 11 - 12 - 13
// |   | \  /
// 3   7  10
// |   |  | \
// 2   6  8  9
// |   |
// 1   5
// 
// Параметры:
//  Элементы - Массив из Произвольный - 
//  Ключ - Строка - имя свойства, которое определяет уникальность элемента. Используется для вывода пути к узлу элемента и для поиска подчиненных элементов, где хранятся только ключи
//  СвойствоПодчиненныхЭлементов - Строка - Свойство подчиненных элементов
//  СвойствоПорядка - Строка - имя свойства, по которому определяется порядок. Тип свойства числовое
//  СвойствоПодчиненныхЭлементов - Строка - имя свойство, в котором хранится список подчиненных элементов
//  Словарь - Соответствие из Произвольный - используется для поиска элемента по ключу, если подчиненные элементы содержат только ключи
//  СвойствоЗначенияСловара - Строка - используется для доступа к подчиненному элементу, если по ключу из словаря элемент содержится в свойстве
// Если в процессе определения порядка обнаруживается циклическая ссылка, то выкидывается исключение с выводом цепочки зависимостей
// 
// Возвращаемое значение:
//  Число - порядок элемента, чем меньше - тем глубже, больше - выше по уровню вложенности элементов ориентированного графа
Функция ОпределитьТопографическийПорядок(Элементы, Ключ = "Идентификатор", СвойствоПодчиненныхЭлементов = "ПодчиненныеЭлементы", СвойствоПорядка = "Порядок", Словарь = Неопределено, СвойствоЗначенияСловара = Неопределено) Экспорт
	ТипКоллекции = ТипЗнч(Элементы);
	ЭтоКлючЗначение = (ТипКоллекции = Тип("Соответствие") ИЛИ ТипКоллекции = Тип("Структура"));
	Если НЕ ЗначениеЗаполнено(Словарь) Тогда
		Словарь = Новый Соответствие;
		Для Каждого ЭлементИлиКлючЗначение Из Элементы Цикл
			Если ЭтоКлючЗначение Тогда
				Элемент = ЭлементИлиКлючЗначение.Значение;
			Иначе
				Элемент = ЭлементИлиКлючЗначение;
			КонецЕсли;
			Словарь[Элемент[Ключ]] = Элемент;
			Элемент[СвойствоПорядка] = -1;
		КонецЦикла;
	Иначе
		Для Каждого ЭлементИлиКлючЗначение Из Элементы Цикл
			Если ЭтоКлючЗначение Тогда
				Элемент = ЭлементИлиКлючЗначение.Значение;
			ИначеЕсли ТипЗнч(ЭлементИлиКлючЗначение) = Тип("Строка") Тогда
				Если ЗначениеЗаполнено(СвойствоЗначенияСловара) Тогда
					Элемент = Словарь[ЭлементИлиКлючЗначение][СвойствоЗначенияСловара];
				Иначе
					Элемент = Словарь[ЭлементИлиКлючЗначение];
				КонецЕсли;
			Иначе
				Элемент = ЭлементИлиКлючЗначение;
			КонецЕсли;
			Элемент[СвойствоПорядка] = -1;
		КонецЦикла;
	КонецЕсли;
	Возврат ОпределитьПорядок(Элементы, СвойствоПорядка, СвойствоПодчиненныхЭлементов, РаботаСОчередью.ОчередьУникальныхЗначений(Ключ), Словарь, СвойствоЗначенияСловара)
КонецФункции

// Выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
// Используется рекурсивный алгоритм с уменьшением базы. Допускается использование только положительных чисел.
// Подробное описание алгоритма в [Распределение суммы по базе](https://infostart.ru/1c/articles/416217/)
// Алгоритм в сравнении с другими в [Честное распределение суммы](https://infostart.ru/1c/tools/16630/) (вариант 3) 
//
// Параметры:
//  РаспределяемаяСумма - Число  - сумма, которую надо распределить. Сумма должна соответствовать определенной точности.
//  Коэффициенты        - Массив из Число - коэффициенты распределения
//  Точность            - Число  - точность округления при распределении. Необязателен.
//
// Возвращаемое значение:
//  Неопределено, Массив из Число - массив размерностью равный массиву коэффициентов, содержит
//           суммы в соответствии с весом коэффициента (из массива коэффициентов).
//           В случае, если распределить невозможно (кол-во коэффициентов = 0
//           есть коэффициенты с отрицательным значением или суммарный вес коэффициентов = 0),
//           тогда будет возвращено Неопределено.
//
// Пример:
//
//	Коэффициенты = Новый Массив;
//	Коэффициенты.Добавить(1);
//	Коэффициенты.Добавить(2);
//	Результат = РаспределитьСумму(1, Коэффициенты);
//	// Результат = [0.33, 0.67]
//
Функция РаспределитьСумму(Знач РаспределяемаяСумма, Знач Коэффициенты, Знач Точность = 2) Экспорт
	Если Коэффициенты.Количество() = 0 ИЛИ РаспределяемаяСумма = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	НужноИнвертироватьРезультат = Ложь;
	Если РаспределяемаяСумма < 0 Тогда
		РаспределяемаяСумма = -РаспределяемаяСумма;
		НужноИнвертироватьРезультат = Истина;
	КонецЕсли;
	КоэффициентыОтрицательны = (Коэффициенты[0] < 0);
	КоэффициентыРаспределения = Новый Массив(Новый ФиксированныйМассив(Коэффициенты)); // Копируем массив в памяти.
	СуммаКоэффициентов = 0;
	Для Индекс = 0 По КоэффициентыРаспределения.Количество() - 1 Цикл
		Коэффициент = КоэффициентыРаспределения[Индекс];
		Если КоэффициентыОтрицательны Тогда
			Если Коэффициент > 0 Тогда
				Возврат Неопределено;
			КонецЕсли;
		Иначе
			Если Коэффициент < 0 Тогда
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
		СуммаКоэффициентов = СуммаКоэффициентов + Коэффициент;
	КонецЦикла;
	Если СуммаКоэффициентов = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = Новый Массив(КоэффициентыРаспределения.Количество());
	ОстатокРаспределения = РаспределяемаяСумма;
	Для Индекс = 0 По КоэффициентыРаспределения.Количество() - 1 Цикл
		Если ОстатокРаспределения = 0 Тогда
			Результат[Индекс] = 0;
			Продолжить;
		КонецЕсли;
		Коэффициент = КоэффициентыРаспределения[Индекс];
		СуммаРаспределения = Мин(ОстатокРаспределения, Окр(ОстатокРаспределения * Коэффициент / СуммаКоэффициентов, Точность, 1));
		Результат[Индекс] = СуммаРаспределения;
		СуммаКоэффициентов = СуммаКоэффициентов - Коэффициент;
		ОстатокРаспределения = ОстатокРаспределения - СуммаРаспределения;
	КонецЦикла;
	Если ОстатокРаспределения <> 0 Тогда
		ВызватьИсключение "Не удалось распределить сумму";
	КонецЕсли;
	Если НужноИнвертироватьРезультат Тогда
		Для Индекс = 0  По Результат.ВГраница() Цикл
			Результат[Индекс] = -Результат[Индекс]; 
		КонецЦикла;		
	КонецЕсли;
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область РаботаСМножеством

// Дополняет массив МассивПриемник значениями из массива МассивИсточник.
// 
// Параметры:
//  МассивПриемник - Массив из Произвольный - массив, в который необходимо добавить значения
//  МассивИсточник - Массив из Произвольный - массив значений для добавления
//  ТолькоУникальныеЗначения - Булево - если истина, то в массив будут добавлены только уникальные значения
//  НижняяГраница - Число - нижняя граница среза
//  ВерхняяГраница - Число - верхняя граница среза
//  Шаг - Число - ширина обхода источника
// 
// Возвращаемое значение:
//  Массив из Произвольный - объединенный массив
Функция Дополнить(МассивПриемник, МассивИсточник, ТолькоУникальныеЗначения = Ложь, НижняяГраница = 0, Знач ВерхняяГраница = Неопределено, Шаг = 1) Экспорт
	Если ВерхняяГраница = Неопределено Тогда
		ВерхняяГраница = МассивИсточник.Количество();
	КонецЕсли;
	Индекс = НижняяГраница;
	Если ТолькоУникальныеЗначения Тогда
		Словарь = Новый Соответствие;
		Для Каждого Значение Из МассивПриемник Цикл
			Словарь.Вставить(Значение, Истина);
		КонецЦикла;
		Пока Индекс < ВерхняяГраница Цикл
			Значение = МассивИсточник[Индекс];
			Если Словарь[Значение] = Неопределено Тогда
				МассивПриемник.Добавить(Значение);
				Словарь.Вставить(Значение, Истина);
			КонецЕсли;
			Индекс = Индекс + Шаг;
		КонецЦикла;
	Иначе
		Пока Индекс < ВерхняяГраница Цикл
			МассивПриемник.Добавить(МассивИсточник[Индекс]);
			Индекс = Индекс + Шаг;
		КонецЦикла;
	КонецЕсли;
	Возврат МассивПриемник;
КонецФункции

// Возвращает разность массивов. Разностью двух массивов является массив, содержащий
// все элементы первого массива, не существующие во втором массиве.
//
// Параметры:
//  Массив - Массив из Произвольный - массив элементов, из которого необходимо выполнить вычитание
//  МассивВычитания - Массив из Произвольный - массив элементов, который будет вычитаться
// 
// Возвращаемое значение:
//  Массив из Произвольный - разностью двух массивов
//
// Пример:
//	//А = [1, 3, 5, 7];
//	//В = [3, 7, 9];
//	Результат = РазностьМассивов(А, В);
//	//Результат = [1, 5];
//
Функция Разность(Знач Массив, Знач МассивВычитания) Экспорт
	Результат = Новый Массив;
	Для Каждого Элемент Из Массив Цикл
		Если МассивВычитания.Найти(Элемент) = Неопределено Тогда
			Результат.Добавить(Элемент);
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция Пересечение(Знач Массив1, Знач Массив2) Экспорт
	Множество1 = РаботаСМножеством.Дополнить(, Массив1);
	Множество2 = РаботаСМножеством.Дополнить(, Массив2);
	Множество = РаботаСМножеством.Пересечение(Множество1, Множество2);
	Возврат РаботаСМножеством.Массив(Множество);
КонецФункции


// Скопировать.
// 
// Параметры:
//  Элементы - Массив из Произвольный
// 
// Возвращаемое значение:
//  Массив из Произвольный - новый массив
Функция Скопировать(Элементы) Экспорт
	Результат = Новый Массив;
	Для Каждого Элемент Из Элементы Цикл
		Результат.Добавить(Элемент);
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Содержит.
// 
// Параметры:
//  Элементы - Массив из Произвольный
//  Значение - Произвольный - искомое значение
// 
// Возвращаемое значение:
//  Булево
Функция Содержит(Элементы, Значение) Экспорт
	Возврат Элементы.Найти(Значение) <> Неопределено;
КонецФункции

#КонецОбласти


#Область РаботаСОчередью

// Положить в очередь с приоритетом.
// 
// Параметры:
//  Очередь - Массив из Произвольный - элементы очереди, по-умолчанию отсортированы от меньшего к большему
//  Элемент - Произвольный - 
//  ФункцияСравнения - Строка - см. Сравнить
//  Контекст - Произвольный
//  Параметры - Произвольный
Процедура ПоложитьВОчередьСПриоритетом(Очередь, Элемент, ФункцияСравнения = "Сравнить(А, Б)", Контекст = Неопределено, Параметры = Неопределено) Экспорт
	ИндексЭлемента = НайтиИндексЭлементаОчередиСПриоритетом(Очередь, Элемент, 0, Очередь.Количество(), ФункцияСравнения, Контекст, Параметры);
	Очередь.Вставить(ИндексЭлемента, Элемент);
КонецПроцедуры

// Найти элемент в очереди с приоритетом. Проверят наличие элемента в очереди с приоритетом
// 
// Параметры:
//  Очередь - Массив из Произвольный - элементы очереди, по-умолчанию отсортированы от меньшего к большему
//  Элемент - Произвольный - 
//  ИндексНачала - Число - Индекс начала
//  ИндексОкончания - Число - Индекс окончания
//  ФункцияСравнения - Строка - см. Сравнить
//  Контекст - Произвольный
//  Параметры - Произвольный
// 
// Возвращаемое значение:
//  Булево - элемент найден
Функция НайтиЭлементОчередиСПриоритетом(Очередь, Элемент, ИндексНачала, ИндексОкончания, ФункцияСравнения, Контекст = Неопределено, Параметры = Неопределено) Экспорт
	#Если НЕ ТонкийКлиент Тогда
		УстановитьБезопасныйРежим(Истина);
	#КонецЕсли
	Если ИндексНачала = ИндексОкончания Тогда
		Возврат Ложь;
	КонецЕсли;
	ИндексСередины = Окр((ИндексНачала + ИндексОкончания) / 2, 0, 0);
	Если ИндексСередины = ИндексОкончания Тогда
		Возврат Ложь;
	КонецЕсли;
	А = Очередь[ИндексСередины];
	Б = Элемент;
	Результат = Вычислить(ФункцияСравнения);
	Если Результат = 0 Тогда
		Возврат Истина;
	ИначеЕсли Результат > 0 Тогда
		Возврат НайтиЭлементОчередиСПриоритетом(Очередь, Элемент, ИндексНачала, ИндексСередины, ФункцияСравнения, Контекст, Параметры);
	Иначе
		Возврат НайтиЭлементОчередиСПриоритетом(Очередь, Элемент, ИндексСередины + 1, ИндексОкончания, ФункцияСравнения, Контекст, Параметры);
	КонецЕсли;
КонецФункции

#КонецОбласти

#Область УстаревшиеПроцедурыИФункции

// Устарела. Дополняет массив МассивПриемник значениями из массива МассивИсточник.
//
// Параметры:
//  МассивПриемник - Массив из Произвольный - массив, в который необходимо добавить значения
//  МассивИсточник - Массив из Произвольный - массив значений для заполнения
//  ТолькоУникальныеЗначения - Булево - если истина, то в массив будут включены только уникальные значения
//
Процедура ДополнитьМассив(МассивПриемник, МассивИсточник, ТолькоУникальныеЗначения = Ложь) Экспорт
	Дополнить(МассивПриемник, МассивИсточник, ТолькоУникальныеЗначения);
КонецПроцедуры

// Устарела. Скопировать
// 
// Параметры:
//  Элементы - Массив из Произвольный
// 
// Возвращаемое значение:
//  Массив из Произвольный - новый массив
Функция СкопироватьМассив(Элементы) Экспорт
	Результат = Новый Массив;
	Для Каждого Элемент Из Элементы Цикл
		Результат.Добавить(Элемент);
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Устарела. push
// Добавить элемент
// 
// Параметры:
//  Элементы - Массив из Произвольный - 
//  Элемент - Произвольный
// 
// Возвращаемое значение:
//  Массив из Произвольный
Функция Положить(Элементы, Элемент) Экспорт
	Элементы.Добавить(Элемент);
	Возврат Элементы;
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция НовыйГруппировка(ПоляГруппировки = Неопределено, ПоляСвертки)
	
	Результат = Новый Структура;
	
	Для Каждого ИмяПоля Из Массив(ПоляГруппировки) Цикл
		Результат.Вставить(ИмяПоля, Неопределено);
	КонецЦикла;
	
	Для Каждого ИмяПоля Из Массив(ПоляСвертки) Цикл
		Результат.Вставить(ИмяПоля, Новый Массив);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Нормализовать.
// 
// Параметры:
//  Строка - Строка - выражение, в котором вместо кавычек использован апостроф "'". Если нужно отключить нормализацию, то 
//  				передать первым символом восклицательный знак "!"
// 
// Возвращаемое значение:
//  Строка - преобразованная строка без "!" в начале и с заменой "'"->""" (если нет "!")
Функция Нормализовать(Строка)
	Возврат ?(Лев(Строка, 1) = "!", Прав(Строка, СтрДлина(Строка) - 1), СтрЗаменить(Строка, "'", """"));
КонецФункции

//  Топографическая сортировка
Функция ОпределитьПорядок(Элементы, СвойствоПорядка, СвойствоПодчиненныхЭлементов, Очередь, Словарь, СвойствоЗначенияСловара, Знач Порядок = 0)
	ТипКоллекции = ТипЗнч(Элементы);
	ЭтоКлючЗначение = (ТипКоллекции = Тип("Соответствие") ИЛИ ТипКоллекции = Тип("Структура"));
	Для Каждого ЭлементИлиКлючЗначение Из Элементы Цикл
		//  Нужно проверить тип элемента. Если это подчиненные элементы, то это ключ, верхнего - это сами элементы
		Если ЭтоКлючЗначение Тогда
			Элемент = ЭлементИлиКлючЗначение.Значение;
		ИначеЕсли ТипЗнч(ЭлементИлиКлючЗначение) = Тип("Строка") Тогда
			Если ЗначениеЗаполнено(СвойствоЗначенияСловара) Тогда
				Элемент = Словарь[ЭлементИлиКлючЗначение][СвойствоЗначенияСловара];
			Иначе
				Элемент = Словарь[ЭлементИлиКлючЗначение];
			КонецЕсли;
		Иначе
			Элемент = ЭлементИлиКлючЗначение;
		КонецЕсли;
		ПорядокЭлемента = Элемент[СвойствоПорядка];
		Если ПорядокЭлемента <> -1 Тогда
			Порядок = Макс(Порядок, ПорядокЭлемента);
			Продолжить;
		КонецЕсли;
		//  Контроль циклической ссылки
		Если РаботаСОчередью.Содержит(Очередь, Элемент) Тогда
			ЭлементыСтека = Отобразить(Очередь.Элементы, СтрШаблон("Элемент['%1']", Очередь.Ключ));
			ЭлементыСтека.Добавить(Элемент[Очередь.Ключ]);
			ВызватьИсключение "Циклическая ссылка: " + СтрСоединить(ЭлементыСтека, "<--");
		КонецЕсли;
		//  Контроль циклической ссылки
		РаботаСОчередью.Положить(Очередь, Элемент);
		//  Рекурсивный спуск
		Порядок = ОпределитьПорядок(Элемент[СвойствоПодчиненныхЭлементов], СвойствоПорядка, СвойствоПодчиненныхЭлементов, Очередь, Словарь, СвойствоЗначенияСловара, Порядок);
		//  Контроль циклической ссылки
		РаботаСОчередью.Взять(Очередь);
		//  Порядок
		Порядок = Порядок + 1;
		Элемент[СвойствоПорядка] = Порядок;
	КонецЦикла;
	Возврат Порядок;
КонецФункции

// Быстрая сортировка (quicksort)
// 
// Параметры:
//  Элементы - Массив из Произвольный
//  ФункцияСравнения - Строка - см. Сравнить
//  Контекст - Произвольный
//  Параметры - Произвольный
//  Нижний - Число - Нижний предел
//  Верхний - Число - Верхний предел
Процедура БыстраяСортировка(Элементы, ФункцияСравнения, Контекст, Параметры, Нижний, Верхний)
	#Если НЕ ТонкийКлиент Тогда
		УстановитьБезопасныйРежим(Истина);
	#КонецЕсли
	Если Нижний < Верхний Тогда
		ОпорныйИндекс = Цел((Верхний + Нижний) / 2);
		// перенос опорного значения в верхний индекс
		Значение = Элементы[ОпорныйИндекс];
		Элементы[ОпорныйИндекс] = Элементы[Верхний];
		Элементы[Верхний] = Значение;
		Б = Элементы[Верхний];// опорное значение
		ИндексРаздела = Нижний - 1;
		Для Индекс = Нижний По Верхний Цикл
			А = Элементы[Индекс];
			Если Вычислить(ФункцияСравнения) >= 0 Тогда // значение меньше или равно опорному в Б (0, 1)
				ИндексРаздела = ИндексРаздела + 1;
				// поменять местами текущий с последним значением на разделе
				Значение = Элементы[ИндексРаздела];
				Элементы[ИндексРаздела] = Элементы[Индекс];
				Элементы[Индекс] = Значение;
			КонецЕсли;
		КонецЦикла;
		БыстраяСортировка(Элементы, ФункцияСравнения, Контекст, Параметры, Нижний, ИндексРаздела - 1);
		БыстраяСортировка(Элементы, ФункцияСравнения, Контекст, Параметры, ИндексРаздела + 1, Верхний);
	КонецЕсли;
КонецПроцедуры

Процедура БыстраяСортировкаПо(Элементы, ПоляСравнения, Нижний, Верхний)
	Если Нижний < Верхний Тогда
		ОпорныйИндекс = Цел((Верхний + Нижний) / 2);
		// перенос опорного значения в верхний индекс
		Значение = Элементы[ОпорныйИндекс];
		Элементы[ОпорныйИндекс] = Элементы[Верхний];
		Элементы[Верхний] = Значение;
		Б = Элементы[Верхний];// опорное значение
		ИндексРаздела = Нижний - 1;
		Для Индекс = Нижний По Верхний Цикл
			А = Элементы[Индекс];
			// СравнитьПо
			РезультатСравнения = 0;
			Для Каждого ПолеСравнения Из ПоляСравнения Цикл
				Поле = ПолеСравнения.Поле;
				А_поле = А[Поле];
				Б_поле = Б[Поле];
		 		// Сравнить
				Если А_поле <> Б_поле Тогда
					Если ПолеСравнения.Направление = "-" Тогда
						РезультатСравнения = ?(А_поле < Б_поле, -1, 1);
					Иначе
						РезультатСравнения = ?(А_поле < Б_поле, 1, -1);
					КонецЕсли;						
				КонецЕсли;
		 		// Первое неравенство определят порядок по всем остальным полям как поле верхнего разряда
				Если РезультатСравнения <> 0 Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
			//
			Если РезультатСравнения >=0 Тогда // значение меньше или равно опорному в Б (0, 1)
				ИндексРаздела = ИндексРаздела + 1;
				// поменять местами текущий с последним значением на разделе
				Значение = Элементы[ИндексРаздела];
				Элементы[ИндексРаздела] = Элементы[Индекс];
				Элементы[Индекс] = Значение;
			КонецЕсли;
		КонецЦикла;
		БыстраяСортировкаПо(Элементы, ПоляСравнения, Нижний, ИндексРаздела - 1);
		БыстраяСортировкаПо(Элементы, ПоляСравнения, ИндексРаздела + 1, Верхний);
	КонецЕсли;
КонецПроцедуры

// Найти индекс элемента очереди с приоритетом.
// 
// Параметры:
//  Очередь - Массив из Произвольный - элементы очереди, по-умолчанию отсортированы от меньшего к большему
//  Элемент - Произвольный - 
//  ИндексНачала - Число - Индекс начала
//  ИндексОкончания - Число - Индекс окончания
//  ФункцияСравнения - Строка - Выражение предиката
//  Контекст - Произвольный, Неопределено - Контекст
//  Параметры - Произвольный, Неопределено - Параметры
// 
// Возвращаемое значение:
//  Число - Найти индекс элемента очереди с приоритетом
Функция НайтиИндексЭлементаОчередиСПриоритетом(Очередь, Элемент, ИндексНачала, ИндексОкончания, ФункцияСравнения, Контекст = Неопределено, Параметры = Неопределено)
	#Если НЕ ТонкийКлиент Тогда
		УстановитьБезопасныйРежим(Истина);
	#КонецЕсли
	Если ИндексНачала = ИндексОкончания Тогда
		Возврат ИндексНачала;
	КонецЕсли;
	ИндексСередины = Окр((ИндексНачала + ИндексОкончания) / 2, 0, 0);
	Если ИндексСередины = ИндексОкончания Тогда
		Возврат ИндексОкончания;
	КонецЕсли;
	А = Очередь[ИндексСередины];
	Б = Элемент;
	Если Вычислить(ФункцияСравнения) > 0 Тогда
		Возврат НайтиИндексЭлементаОчередиСПриоритетом(Очередь, Элемент, ИндексНачала, ИндексСередины, ФункцияСравнения, Контекст, Параметры);
	Иначе
		Возврат НайтиИндексЭлементаОчередиСПриоритетом(Очередь, Элемент, ИндексСередины + 1, ИндексОкончания, ФункцияСравнения, Контекст, Параметры);
	КонецЕсли;
КонецФункции

Процедура СортироватьЭлементы(Элементы, ВыражениеПредиката, НижнийПредел, ВерхнийПредел)
	#Если НЕ ТонкийКлиент Тогда
		УстановитьБезопасныйРежим(Истина);
	#КонецЕсли
    Начало = НижнийПредел;
    Конец = ВерхнийПредел;
    Б = Элементы[Цел((Начало + Конец)/2)];
	Пока Истина Цикл
		А = Элементы[Начало];
        Пока Вычислить(ВыражениеПредиката) < 0 Цикл // Элементы[Начало] < Б
            Начало = Начало + 1;                   
			А = Элементы[Начало];
		КонецЦикла;
		А = Элементы[Конец];
        Пока Вычислить(ВыражениеПредиката) > 0 Цикл // Элементы[Конец] > Б
            Конец = Конец - 1;                   
			А = Элементы[Конец];
        КонецЦикла; 
        Если Начало <= Конец Тогда               
            //  Дерево значений
            //  Начало -> Конец
            //  Конец -> Начало 
			ШагСдвига = Конец - Начало;
			Если НЕ ШагСдвига = 0 Тогда
				Элементы.Сдвинуть(Начало, ШагСдвига);
				ШагСдвига = ШагСдвига - 1;
				Если НЕ ШагСдвига = 0 Тогда
					Элементы.Сдвинуть(Конец - 1, -ШагСдвига);
				КонецЕсли;
			КонецЕсли;
            //  Дерево значений            
            Начало = Начало + 1;
            Конец = Конец - 1;            
        КонецЕсли;
        Если Начало > Конец Тогда                       
            Прервать;                        
        КонецЕсли;
	КонецЦикла;
    Если НижнийПредел < Конец Тогда         
        СортироватьЭлементы(Элементы, ВыражениеПредиката, НижнийПредел, Конец);        
	КонецЕсли; 
    Если Начало < ВерхнийПредел Тогда                      
        СортироватьЭлементы(Элементы, ВыражениеПредиката, Начало, ВерхнийПредел);        
    КонецЕсли;
КонецПроцедуры

#КонецОбласти